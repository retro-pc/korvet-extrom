;**********************************************************************************************
;*  Загрузчик 1 фазы дискового эмулятора Korvet-Extrom
;*  Работает только в паре с контроллером Extrom через боковой разъем корвета
;*
;*  Получает от контроллера файл загрузчика 2 фазы, размещает в памяти и запускает
;*   Сборка с помощью кросс-ассемблера z80asm, контрольная сумма рассчитывается утилитой ercs
;*
;*   Программа записывается в nvram контроллера с адреса 0
;**********************************************************************************************
BASE	EQU	0F600H		; База для размещения этого кода
CWR	EQU     0FB0BH		; Порт управления ВВ55 #3
PORTC	EQU     0FB0AH		; Порт C ВВ55 #3
TRAM	EQU	0FC00H		; Начало видеопамяти
KBD4	EQU	0F810H		; Строка А4 клавиатуры (с цифрами)


STRCPY  EQU	0C0h		; Коприрование строки из HL в DE

	ORG   	BASE

; Стандартный заголовок внешнего ПЗУ корвета
	JP	START	        ; +0
	DB      0		; +3
	DW	START           ; +4 - адрес запуска 
	DB	BASE>>8         ; +6 - старшие 8 бит адреса загрузки (младшие всегда 00)
	DB	01H             ; +7 - количество загружаемых 256-байтовых блоков


; Далее идет непосредственный программный код	
START:
	DI

; Печать промпта 	
	LD	HL,MSG
	LD	DE,TRAM		; в начало АЦЗУ
	CALL	STRCPY		; (DE) будет указателем в АЦЗУ для печати прогресс-бара

; Настройка ВВ55	
	LD	HL,CWR
	LD	(HL),0C0h	; Конифгурация ВВ55 - Порт А в режиме 2, порт В на вывод

; Опрос цифрового ряда клавиатуры
;   В конце опроса A будет содержать номер кнопки (0-7) или 8 если ни одна не нажата
; 
	LD	HL,KBD4
	LD	A,(HL)		; состояние кнопок 0-7
	LD	C,8		; счетчик битов
KL1:	
	RRCA			; проверяем очередной бит
	JP	C,KL2		; он поднят - выходим
	DEC	C		; проверяем остальные 8 бит
	JP	NZ,KL1		
KL2:	
	LD	A,8		; инвертируем номер кнопки
	SUB	C
	CALL	PUTBYTE		; Отправка номера загружаемого файла
	
; Получение параметров загрузки
	CALL	GETBYTE		; получаем старший байт адреса загрузки
	LD	H,A
	LD	L,0		; HL - адрес загрузки, малдший байт - 0
	
	LD	C,L		; младший байт размера - тоже 0           
	CALL	GETBYTE		; размер файла в блоках
	LD	B,A		; BC - размер файла в байтах, всегда кратен 256
	PUSH	HL		; сохраняем указатель на начало блока в памяти

; Печать параметров загрузки
	LD	A,H
	CALL	HEX2
	LD	A,L
	CALL	HEX2
	LD	A,'-'
	LD	(DE),A
	INC	DE
	LD	A,B		; после минуса идет размер файла
	CALL	HEX2
	
; Получение и размещение самого файла
FL:	
	CALL	GETBYTE		; очередной байт файла
	LD	(HL),A		; размещаем его в памти
	INC	HL
	DEC	BC		; счетчик байтов --
	LD	A,B
	OR	C		; bc=0?
	JP	Z,FDONE		; да - все байты уже загружены
	LD	A,C
	OR	A		; граница блока?
	JP	NZ,FL		; нет
	LD	A,'*'
	LD	(DE),A		; выводим очередной байт прогресс-бара на экран
	INC	DE		; продвигаем позицию в АЦЗУ
	JP	FL		; продолжаем загрузку

; Загрузка окончена - запускаем код

FDONE:	
        POP	BC		; адрес начала файла в памяти
        LD	C,4		; +4 - адрес запуска
        LD	A,(BC)
        LD	L,A		; выбираем оба байта адреса
        INC	C
        LD	A,(BC)
        LD	H,A
        JP	(HL)		; запускаем код

;****************************************
;*  Прием байта из порта А по стробу    *
;****************************************
GETBYTE:
	PUSH	HL
	LD	HL,PORTC
WG:
	LD	A,(HL)		; слово состояния ВВ55 - берется из порта С
	AND	20h		; выделяем сигнал IBF
	JP	Z,WG		; IBF=0 - данных еще нет
	DEC	L
	DEC	L
	LD	A,(HL)		; данные поступили - выбираем их из порта А
	POP	HL
	RET

;****************************************
;*  Отправка байта в порт A             *
;****************************************
PUTBYTE:
	PUSH	HL
	PUSH	AF
	LD	HL,PORTC
WP:
	LD	A,(HL)		; слово состояния ВВ55 - берется из порта С
	AND	80h		; выделяем сигнал -OBF
	JP	Z,WP		; -OBF=0 - в передатчике сидит незабранный байт
	DEC	L
	DEC	L
	POP	AF
	LD	(HL),A
	POP	HL
	RET

;****************************************
;*      Печать полубайта в HEX          *
;****************************************

HEX1:
	AND	0Fh		; младший полубайт 
	ADD	'0'		; в ASCII
	CP	3Ah		; 0-9?
	JP	C,H1D		; да
	ADD	7		; коррекция до A-F
H1D:	LD	(DE),A		; в АЦЗУ
	INC	DE
	RET

;****************************************
;*      Печать байта в HEX              *
;****************************************

HEX2:	PUSH	AF
	RRCA
	RRCA			; сдвигаем старший полубайт в младший
	RRCA
	RRCA
	CALL	HEX1		; печатаем его
	POP	AF
	AND	0Fh		
	CALL	HEX1		; печатаем младший полубайт
	RET
	
MSG:    DB	"BOOT:",0	; текстовое сообщение на экран
        DC      BASE+100h-$,0FFh	; заполнитель до конца 256-байтного блока
	END
    